<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · uCSV.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>uCSV.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Home</a><ul class="internal"><li><a class="toctext" href="#Functions-1">Functions</a></li><li><a class="toctext" href="#Manual-1">Manual</a></li></ul></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="man/defaults.html">Getting Started</a></li><li><a class="toctext" href="man/headers.html">Headers</a></li><li><a class="toctext" href="man/dataframes.html">Reading into DataFrames</a></li><li><a class="toctext" href="man/delimiters.html">Delimiters</a></li><li><a class="toctext" href="man/missingdata.html">Missing Data</a></li><li><a class="toctext" href="man/declaring-column-element-types.html">Declaring Column Element Types</a></li><li><a class="toctext" href="man/declaring-column-vector-types.html">Declaring Column Vector Types</a></li><li><a class="toctext" href="man/international.html">International Representations for Numbers</a></li><li><a class="toctext" href="man/customparsers.html">Custom Parsers</a></li><li><a class="toctext" href="man/quotes-escapes.html">Quotes and Escapes</a></li><li><a class="toctext" href="man/comments-skiplines.html">Skipping Comments and Rows</a></li><li><a class="toctext" href="man/malformed.html">Malformed Data</a></li><li><a class="toctext" href="man/url.html">Reading Data from URLs</a></li><li><a class="toctext" href="man/compressed.html">Reading Compressed Datasets</a></li><li><a class="toctext" href="man/unsupported.html">Common Formatting Issues</a></li><li><a class="toctext" href="man/write.html">Writing Data</a></li><li><a class="toctext" href="man/benchmarks.html">Benchmarks</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Home</a></li></ul><a class="edit-page" href="https://github.com/cjprybol/uCSV.jl/tree/6ec28deee4391dd6aa56c3fdc30330c386f78dd2/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="uCSV.jl-Documentation-1" href="#uCSV.jl-Documentation-1">uCSV.jl Documentation</a></h1><h2><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="uCSV.read" href="#uCSV.read"><code>uCSV.read</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">read(input;
     delim=&#39;,&#39;,
     quotes=null,
     escape=null,
     comment=null,
     encodings=Dict{String, Any}(),
     header=0,
     skiprows=Vector{Int}(),
     types=Dict{Int,DataType}(),
     isnullable=Dict{Int,Bool}(),
     coltypes=Vector,
     colparsers=Dict{Int,Function}(),
     typeparsers=Dict{DataType, Function}(),
     typedetectrows=1,
     skipmalformed=false,
     trimwhitespace=false)</code></pre><p>Take an input file or IO source and user-defined parsing rules and return:</p><ol><li><p>a <code>Vector{Any}</code> containing the parsed columns</p></li><li><p>a <code>Vector{String}</code> containing the header (column names)</p></li></ol><p><strong>Arguments</strong></p><ul><li><p><code>input</code></p><ul><li><p>the path to a local file, or an open IO source from which to read data</p></li></ul></li><li><p><code>delim</code></p><ul><li><p>a <code>Char</code> or <code>String</code> that separates fields in the dataset</p></li><li><p>default: <code>delim=&#39;,&#39;</code></p><ul><li><p>for CSV files</p></li></ul></li><li><p>frequently used:</p><ul><li><p><code>delim=&#39;\t&#39;</code></p></li><li><p><code>delim=&#39; &#39;</code></p></li><li><p><code>delim=&#39;|&#39;</code></p></li></ul></li></ul></li><li><p><code>quotes</code></p><ul><li><p>a <code>Char</code> used for quoting fields in the dataset</p></li><li><p>default: <code>quotes=null</code></p><ul><li><p>by default, the parser does not check for quotes</p></li></ul></li><li><p>frequently used:</p><ul><li><p><code>quotes=&#39;&quot;&#39;</code></p></li></ul></li></ul></li><li><p><code>escape</code></p><ul><li><p>a <code>Char</code> used for escaping other reserved parsing characters</p></li><li><p>default: <code>escape=null</code></p><ul><li><p>by default, the parser does not check for escapes</p></li></ul></li><li><p>frequently used:</p><ul><li><p><code>escape=&#39;&quot;&#39;</code></p><ul><li><p>double-quotes within quotes, e.g. <code>&quot;firstname &quot;&quot;nickname&quot;&quot; lastname&quot;</code></p></li></ul></li><li><p><code>escape=&#39;\\&#39;</code></p><ul><li><p>note that the first backslash is just to escape the second backslash</p></li><li><p>e.g. <code>&quot;firstname \&quot;nickname\&quot; lastname&quot;</code></p></li></ul></li></ul></li></ul></li><li><p><code>comment</code></p><ul><li><p>a <code>Char</code> or <code>String</code> at the beginning of lines that should be skipped as comments</p><ul><li><p>note that skipped comment lines do not contribute to the line count for the header (if the user requests parsing a header on a specific row) or for skiprows</p></li></ul></li><li><p>default: <code>comment=null</code></p><ul><li><p>by default, the parser does not check for comments</p></li></ul></li><li><p>frequently used:</p><ul><li><p><code>comment=&#39;#&#39;</code></p></li><li><p><code>comment=&#39;!&#39;</code></p></li><li><p><code>comment=&quot;#!&quot;</code></p></li></ul></li></ul></li><li><p><code>encodings</code></p><ul><li><p>a <code>Dict{String, Any}</code> mapping parsed fields to Julia values</p><ul><li><p>if your dataset has booleans that are not represented as <code>&quot;true&quot;</code> and <code>&quot;false&quot;</code> or missing values that you&#39;d like to read as <code>null</code>s, you&#39;ll need to use this!</p></li></ul></li><li><p>default: <code>encodings=Dict{String, Any}()</code></p><ul><li><p>by default, the parser does not check for any reserved fields</p></li></ul></li><li><p>frequently used:</p><ul><li><p><code>encodings=Dict(&quot;&quot; =&gt; null)</code></p></li><li><p><code>encodings=Dict(&quot;NA&quot; =&gt; null)</code></p></li><li><p><code>encodings=Dict(&quot;N/A&quot; =&gt; null)</code></p></li><li><p><code>encodings=Dict(&quot;NULL&quot; =&gt; null)</code></p></li><li><p><code>encodings=Dict(&quot;TRUE&quot; =&gt; true, &quot;FALSE&quot; =&gt; false)</code></p></li><li><p><code>encodings=Dict(&quot;True&quot; =&gt; true, &quot;False&quot; =&gt; false)</code></p></li><li><p><code>encodings=Dict(&quot;T&quot; =&gt; true, &quot;F&quot; =&gt; false)</code></p></li><li><p><code>encodings=Dict(&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false)</code></p></li><li><p>... your encodings here ...</p><ul><li><p>can include any number of <code>String</code> =&gt; value mappings</p></li><li><p>note that if the user requests <code>quotes</code>, <code>escapes</code>, or <code>trimwhitespace</code>, these requests will be applied (removed) the raw string <em>BEFORE</em> checking whether the field matches any strings in in the <code>encodings</code> argument</p></li></ul></li></ul></li></ul></li><li><p><code>header</code></p><ul><li><p>an <code>Int</code> indicating which line of the dataset contains column names or a <code>Vector{String}</code> of column names</p><ul><li><p>note that commented lines and blank lines do not contribute to this value e.g. if the first 3 lines of your dataset are comments, you&#39;ll still need to set <code>header=1</code> to interpret the first line of parsed data as the header</p></li></ul></li><li><p>default: <code>header=0</code></p><ul><li><p>no header is checked for by default</p></li></ul></li><li><p>frequently used:</p><ul><li><p><code>header=1</code></p></li></ul></li></ul></li><li><p><code>skiprows</code></p><ul><li><p>a <code>Range</code> or <code>Vector</code> of <code>Int</code>s indicating which rows to skip in the dataset</p><ul><li><p>note that this is 1-based in reference to the first row <em>AFTER</em> the header. if <code>header=0</code> or is provided by the user, this will be the first non-empty line in the dataset. otherwise <code>skiprows=1:1</code> will skip the <code>header+1</code>-nth line in the file</p></li></ul></li><li><p>default: <code>skiprows=Vector{Int}()</code></p><ul><li><p>no rows are skipped</p></li></ul></li></ul></li><li><p><code>types</code></p><ul><li><p>declare the types of the columns</p><ul><li><p>scalar, e.g. <code>types=Bool</code></p><ul><li><p>scalars will be broadcast to apply to every column of the dataset</p></li></ul></li><li><p>vector, e.g. <code>types=[Bool, Int, Float64, String, Symbol, Date, DateTime]</code></p><ul><li><p>the vector length must match the number of parsed columns</p></li></ul></li><li><p>dictionary, e.g. <code>types=(&quot;column1&quot; =&gt; Bool)</code> or <code>types=(1 =&gt; Union{Int, Null})</code></p><ul><li><p>users can refer to the columns by name (only if a header is provided or parsed!) or by index</p></li></ul></li></ul></li><li><p>default:</p><ul><li><p><code>types=Dict{Int,DataType}()</code></p><ul><li><p>column-types will be interpreted from the dataset</p></li></ul></li></ul></li><li><p>built-in support for parsing the following:</p><ul><li><p><code>Int</code></p></li><li><p><code>Float64</code></p></li><li><p><code>String</code></p></li><li><p><code>Symbol</code></p></li><li><p><code>Date</code> – only the default date format will work</p></li><li><p><code>DateTime</code> – only the default datetime format will work</p></li><li><p>for other types or unsupported formats, see <code>colparsers</code> and <code>typeparsers</code></p></li></ul></li></ul></li><li><p><code>isnullable</code></p><ul><li><p>declare whether columns should have element-type <code>Union{T, Null} where T</code></p><ul><li><p>boolean scalar, e.g. <code>isnullable=true</code></p><ul><li><p>scalars will be broadcast to apply to every column of the dataset</p></li></ul></li><li><p>vector, e.g. <code>isnullable=[true, false, true, true]</code></p><ul><li><p>the vector length must match the number of parsed columns</p></li></ul></li><li><p>dictionary, e.g. <code>isnullable=(&quot;column1&quot; =&gt; true)</code> or <code>isnullable=(17 =&gt; true)</code></p><ul><li><p>users can refer to the columns by name (only if a header is provided or parsed!) or by index</p></li></ul></li></ul></li><li><p>default: <code>isnullable=Dict{Int,Bool}()</code></p><ul><li><p>column-types are only nullable if null values are detected in rows <code>1:typedetectrows</code></p></li></ul></li></ul></li><li><p><code>coltypes</code></p><ul><li><p>declare the type of vector that should be used for columns</p></li><li><p>should work for any AbstractVector that allows <code>push!</code>ing values</p><ul><li><p>scalar, e.g. <code>coltypes=CategoricalVector</code></p><ul><li><p>scalars will be broadcast to apply to every column of the dataset</p></li></ul></li><li><p>vector, e.g. <code>coltypes=[CategoricalVector, Vector, CategoricalVector]</code></p><ul><li><p>the vector length must match the number of parsed columns</p></li></ul></li><li><p>dictionary, e.g. <code>coltypes=(&quot;column1&quot; =&gt; CategoricalVector)</code> or <code>coltypes=(17 =&gt; CategoricalVector)</code></p><ul><li><p>users can refer to the columns by name (only if a header is provided or parsed!) or by index</p></li></ul></li></ul></li><li><p>default: <code>coltypes=Vector</code></p><ul><li><p>all columns are returned as standard julia <code>Vector</code>s</p></li></ul></li></ul></li><li><p><code>colparsers</code></p><ul><li><p>provide custom functions for converting parsed strings to values by column</p><ul><li><p>scalar, e.g. <code>colparsers=(x -&gt; parse(Float64, replace(x, &#39;,&#39;, &#39;.&#39;)))</code></p><ul><li><p>scalars will be broadcast to apply to every column of the dataset</p></li></ul></li><li><p>vector, e.g. <code>colparsers=[x -&gt; mydateparser(x), x -&gt; mytimeparser(x)]</code></p><ul><li><p>the vector length must match the number of parsed columns</p></li></ul></li><li><p>dictionary, e.g. <code>colparsers=(&quot;column1&quot; =&gt; x -&gt; mydateparser(x))</code></p><ul><li><p>users can refer to the columns by name (only if a header is provided or parsed!) or by index</p></li></ul></li></ul></li><li><p>default: <code>colparsers=Dict{Int,Function}()</code></p><ul><li><p>column parsers are determined based on user-specified types and those detected from the data</p></li></ul></li></ul></li><li><p><code>typeparsers</code></p><ul><li><p>provide custom functions for converting parsed strings to values by column type</p><ul><li><p><em>NOTE</em> must be used with <code>coltypes</code>. If you supply a custom Int parser you&#39;d like to use to parse column 6, you&#39;ll need to set <code>coltypes=dict(6 =&gt; Int)</code> for it to work</p></li></ul></li><li><p>default: <code>colparsers=Dict{DataType, Function}()</code></p><ul><li><p>column parsers are determined based on user-specified types and those detected from the data</p></li></ul></li><li><p>frequently used:</p><ul><li><p><code>typeparsers=Dict(Float64 =&gt; x -&gt; parse(Float64, replace(x, &#39;,&#39;, &#39;.&#39;)))</code> # decimal-comma floats!</p></li></ul></li></ul></li><li><p><code>typedetectrows</code></p><ul><li><p>specify how many rows of data to read before interpretting the values that each column should take on</p></li><li><p>default: <code>typedetectrows=1</code></p><ul><li><p>must be &gt;= 1</p></li><li><p>commented, skipped, and empty lines are not counted when determining which rows are used for type detection, e.g. setting <code>typedetectrows=10</code> and <code>skiprows=1:5</code> means type detection will occur on rows <code>6:15</code></p></li></ul></li></ul></li><li><p><code>skipmalformed</code></p><ul><li><p>specify whether the parser should skip a line or fail with an error if a line is parsed but does not contain the expected number of rows</p></li><li><p>default: <code>skipmalformed=false</code></p><ul><li><p>malformed lines result in an error</p></li></ul></li></ul></li><li><p><code>trimwhitespace</code></p><ul><li><p>specify whether should extra whitespace be removed from the beginning and ends of fields.</p><ul><li><p>e.g <code>...., myfield ,...</code></p><ul><li><p><code>trimwhitespace=false</code> -&gt; <code>&quot; myfield &quot;</code></p></li><li><p><code>trimwhitespace=true</code>  -&gt; <code>&quot;myfield&quot;</code></p></li></ul></li></ul></li><li><p>leading and trailing whitespace <em>OUTSIDE</em> of quoted fields is trimmed by default.</p><ul><li><p>e.g. <code>...., &quot; myfield &quot; ,...</code> -&gt; <code>&quot; myfield &quot;</code> when <code>quotes=&#39;&quot;&#39;</code></p></li></ul></li><li><p><code>trimwhitespace=true</code> will also trim leading and trailing whitespace <em>WITHIN</em> quotes</p></li><li><p>default: <code>trimwhitespace=false</code></p></li></ul></li></ul></div><a class="source-link" target="_blank" href="https://github.com/cjprybol/uCSV.jl/tree/6ec28deee4391dd6aa56c3fdc30330c386f78dd2/src/read.jl#L1-L183">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="uCSV.write" href="#uCSV.write"><code>uCSV.write</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">function write(output;
               header=null,
               data=null,
               delim=&#39;,&#39;,
               quotes=null,
               quotetypes=AbstractString)</code></pre><p>Write a dataset to disk or IO</p><p><strong>Arguments</strong></p><ul><li><p><code>output</code></p><ul><li><p>the path on disk or IO where you want to write to</p></li></ul></li><li><p><code>header</code></p><ul><li><p>the column names for the data to <code>output</code></p></li><li><p>default: <code>header=null</code></p><ul><li><p>no header is written</p></li></ul></li></ul></li><li><p><code>data</code></p><ul><li><p>the dataset to write to <code>output</code></p></li><li><p>default: <code>data=null</code></p><ul><li><p>no data is written</p></li></ul></li></ul></li><li><p><code>delim</code></p><ul><li><p>the delimiter to seperate fields by</p></li><li><p>default: <code>delim=&#39;,&#39;</code></p><ul><li><p>for CSV files</p></li></ul></li><li><p>frequently used:</p><ul><li><p><code>delim=&#39;\t&#39;</code></p></li><li><p><code>delim=&#39; &#39;</code></p></li><li><p><code>delim=&#39;|&#39;</code></p></li></ul></li></ul></li><li><p><code>quotes</code></p><ul><li><p>the quoting character to use when writing fields</p></li><li><p>default: <code>quotes=null</code></p><ul><li><p>fields are not quoted by default, and fields are written using julia&#39;s default string-printing mechanisms</p></li></ul></li></ul></li><li><p><code>quotetypes::Type</code></p><ul><li><p>when quoting fields, quote only columns where <code>coltype &lt;: quotetypes</code></p><ul><li><p>columns of type <code>Union{&lt;:quotetypes, Null}</code> will also be quoted</p></li></ul></li><li><p>default: <code>quotetypes=AbsractString</code></p><ul><li><p>only the header and fields where <code>coltype &lt;: AbsractString</code> will be quoted</p></li></ul></li><li><p>frequently used:</p><ul><li><p><code>quotetypes=Any</code></p><ul><li><p>quote every field in the dataset</p></li></ul></li></ul></li></ul></li></ul></div><a class="source-link" target="_blank" href="https://github.com/cjprybol/uCSV.jl/tree/6ec28deee4391dd6aa56c3fdc30330c386f78dd2/src/write.jl#L1-L43">source</a><br/><div><pre><code class="language-none">function write(output,
               df;
               delim=&#39;,&#39;,
               quotes=null,
               quotetypes=AbstractString)</code></pre><p>Write a DataFrame to disk or IO</p></div><a class="source-link" target="_blank" href="https://github.com/cjprybol/uCSV.jl/tree/6ec28deee4391dd6aa56c3fdc30330c386f78dd2/src/write.jl#L94-L102">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="uCSV.tomatrix" href="#uCSV.tomatrix"><code>uCSV.tomatrix</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Convert the data output by uCSV.read to a <code>Matrix</code>. Column names are ignored</p></div><a class="source-link" target="_blank" href="https://github.com/cjprybol/uCSV.jl/tree/6ec28deee4391dd6aa56c3fdc30330c386f78dd2/src/helperfunctions.jl#L93">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="uCSV.tovector" href="#uCSV.tovector"><code>uCSV.tovector</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Convert the data output by uCSV.read to a <code>Vector</code>. Column names are ignored</p></div><a class="source-link" target="_blank" href="https://github.com/cjprybol/uCSV.jl/tree/6ec28deee4391dd6aa56c3fdc30330c386f78dd2/src/helperfunctions.jl#L105">source</a><br/></section><h2><a class="nav-anchor" id="Manual-1" href="#Manual-1">Manual</a></h2><ul><li><a href="man/defaults.html#Getting-Started-1">Getting Started</a></li><li><a href="man/headers.html#Headers-1">Headers</a></li><li><a href="man/dataframes.html#Reading-into-DataFrames-1">Reading into DataFrames</a></li><li><a href="man/delimiters.html#Delimiters-1">Delimiters</a></li><li><a href="man/missingdata.html#Missing-Data-1">Missing Data</a></li><li><a href="man/declaring-column-element-types.html#Declaring-Column-Element-Types-1">Declaring Column Element Types</a></li><li><a href="man/declaring-column-vector-types.html#Declaring-Column-Vector-Types-1">Declaring Column Vector Types</a></li><li><a href="man/international.html#International-Representations-for-Numbers-1">International Representations for Numbers</a></li><li><a href="man/customparsers.html#Custom-Parsers-1">Custom Parsers</a></li><li><a href="man/quotes-escapes.html#Quotes-and-Escapes-1">Quotes and Escapes</a></li><li><a href="man/comments-skiplines.html#Skipping-Comments-and-Rows-1">Skipping Comments and Rows</a></li><li><a href="man/malformed.html#Malformed-Data-1">Malformed Data</a></li><li><a href="man/url.html#Reading-Data-from-URLs-1">Reading Data from URLs</a></li><li><a href="man/compressed.html#Reading-Compressed-Datasets-1">Reading Compressed Datasets</a></li><li><a href="man/unsupported.html#Common-Formatting-Issues-1">Common Formatting Issues</a></li><li><a href="man/write.html#Writing-Data-1">Writing Data</a></li><li><a href="man/benchmarks.html#Benchmarks-1">Benchmarks</a></li></ul><footer><hr/><a class="next" href="man/defaults.html"><span class="direction">Next</span><span class="title">Getting Started</span></a></footer></article></body></html>
