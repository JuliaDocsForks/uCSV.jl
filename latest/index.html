<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · uCSV.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>uCSV.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Home</a><ul class="internal"><li><a class="toctext" href="#Functions-1">Functions</a></li><li><a class="toctext" href="#Manual-1">Manual</a></li></ul></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="man/defaults.html">Getting Started</a></li><li><a class="toctext" href="man/headers.html">Headers</a></li><li><a class="toctext" href="man/dataframes.html">Reading into DataFrames</a></li><li><a class="toctext" href="man/delimiters.html">Delimiters</a></li><li><a class="toctext" href="man/missingdata.html">Missing Data</a></li><li><a class="toctext" href="man/declaring-column-element-types.html">Declaring Column Element Types</a></li><li><a class="toctext" href="man/declaring-column-vector-types.html">Declaring Column Vector Types</a></li><li><a class="toctext" href="man/international.html">International Representations for Numbers</a></li><li><a class="toctext" href="man/customparsers.html">Custom Parsers</a></li><li><a class="toctext" href="man/quotes-escapes.html">Quotes and Escapes</a></li><li><a class="toctext" href="man/comments-skiplines.html">Skipping Comments and Rows</a></li><li><a class="toctext" href="man/malformed.html">Malformed Data</a></li><li><a class="toctext" href="man/url.html">Reading data from URLs</a></li><li><a class="toctext" href="man/compressed.html">Reading Compressed Datasets</a></li><li><a class="toctext" href="man/unsupported.html">Common formatting issues</a></li><li><a class="toctext" href="man/benchmarks.html">Benchmarks</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Home</a></li></ul><a class="edit-page" href="https://github.com/cjprybol/uCSV.jl/tree/8322eb7b21a588a9d3627c57e41213ae0f8d276b/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="uCSV.jl-Documentation-1" href="#uCSV.jl-Documentation-1">uCSV.jl Documentation</a></h1><h2><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="uCSV.read" href="#uCSV.read"><code>uCSV.read</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">read(fullpath;
     delim=&#39;,&#39;,
     quotes=null,
     escape=null,
     comment=null,
     encodings=Dict{String, Any}(),
     header=0,
     skiprows=Vector{Int}(),
     types=Dict{Int,DataType}(),
     isnullable=Dict{Int,Bool}(),
     coltypes=Vector,
     colparsers=Dict{Int,Function}(),
     typeparsers=Dict{DataType, Function}(),
     typedetectrows=1,
     skipmalformed=false,
     trimwhitespace=false)</code></pre><p>Take an input file or IO source and user-defined parsing rules and return:</p><ol><li><p>a <code>Vector{Any}</code> containing the parsed columns</p></li><li><p>a <code>Vector{String}</code> containing the header (column names)</p></li></ol><p><strong>Arguments</strong></p><ul><li><p><code>fullpath::Union{String,IO}</code></p><ul><li><p>the path to a local file, or an open IO source from which to read data</p></li></ul></li><li><p><code>delim::Union{Char,String}</code></p><ul><li><p>whatever the dataset is being split on</p></li><li><p>default: <code>delim=&#39;,&#39;</code></p><ul><li><p>for CSV files</p></li></ul></li><li><p>frequently used:</p><ul><li><p><code>delim=&#39;\t&#39;</code></p></li><li><p><code>delim=&#39; &#39;</code></p></li><li><p><code>delim=&#39;|&#39;</code></p></li></ul></li><li><p>may contain any valid UTF-8 character or string</p></li></ul></li><li><p><code>quotes::Union{Char,Null}</code></p><ul><li><p>the character used for quoting fields in the dataset</p></li><li><p>default: <code>quotes=null</code></p><ul><li><p>by default, the parser does not check for quotes.</p></li></ul></li><li><p>frequently used:</p><ul><li><p><code>quotes=&#39;&quot;&#39;</code></p></li></ul></li></ul></li><li><p><code>escape::Union{Char,Null}</code></p><ul><li><p>the character used for escaping other special &amp; reserved parsing characters</p></li><li><p>default: <code>escape=null</code></p><ul><li><p>by default, the parser does not check for escapes.</p></li></ul></li><li><p>frequently used:</p><ul><li><p><code>escape=&#39;&quot;&#39;</code></p><ul><li><p>double-quotes within quotes, e.g. <code>&quot;firstname &quot;&quot;nickname&quot;&quot; lastname&quot;</code></p></li></ul></li><li><p><code>escape=&#39;\\&#39;</code></p><ul><li><p>note that the first backslash is just to escape the second backslash</p></li><li><p>e.g. <code>&quot;firstname \&quot;nickname\&quot; lastname&quot;</code></p></li></ul></li></ul></li></ul></li><li><p><code>comment::Union{Char,String,Null}</code></p><ul><li><p>the character or string used for comment lines in your dataset</p><ul><li><p>note that skipped comment lines do not contribute to the line count for the header (if the user requests parsing a header on a specific row) or for skiprows</p></li></ul></li><li><p>default: <code>comment=null</code></p><ul><li><p>by default, the parser does not check for comments</p></li></ul></li><li><p>frequently used:</p><ul><li><p><code>comment=&#39;#&#39;</code></p></li><li><p><code>comment=&#39;!&#39;</code></p></li><li><p><code>comment=&quot;#!&quot;</code></p></li></ul></li></ul></li><li><p><code>encodings::Dict{String,Any}</code></p><ul><li><p>A dictionary mapping parsed strings to desired julia values</p><ul><li><p>if your dataset has booleans that are not represented as <code>&quot;true&quot;</code> and <code>&quot;false&quot;</code> or missing values that you&#39;d like to read as <code>null</code>s, you&#39;ll need to use this!</p></li></ul></li><li><p>default: <code>encodings=Dict{String, Any}()</code></p><ul><li><p>by default, the parser does not check for any reserved fields</p></li></ul></li><li><p>frequently used:</p><ul><li><p><code>encodings=Dict{String, Any}(&quot;&quot; =&gt; null)</code></p></li><li><p><code>encodings=Dict{String, Any}(&quot;NA&quot; =&gt; null)</code></p></li><li><p><code>encodings=Dict{String, Any}(&quot;N/A&quot; =&gt; null)</code></p></li><li><p><code>encodings=Dict{String, Any}(&quot;NULL&quot; =&gt; null)</code></p></li><li><p><code>encodings=Dict{String, Any}(&quot;TRUE&quot; =&gt; true, &quot;FALSE&quot; =&gt; false)</code></p></li><li><p><code>encodings=Dict{String, Any}(&quot;True&quot; =&gt; true, &quot;False&quot; =&gt; false)</code></p></li><li><p><code>encodings=Dict{String, Any}(&quot;T&quot; =&gt; true, &quot;F&quot; =&gt; false)</code></p></li><li><p><code>encodings=Dict{String, Any}(&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false)</code></p></li><li><p>... your encodings here ...</p><ul><li><p>can include any number of <code>String</code> =&gt; value mappings</p></li><li><p>note that if the user requests <code>quotes</code>, <code>escapes</code>, or <code>trimwhitespace</code>, these requests will be applied (removed) the raw string <em>BEFORE</em> checking whether the field matches any strings in in the <code>encodings</code> argument.</p></li></ul></li></ul></li></ul></li><li><p><code>header::Union{Integer,Vector{String}}</code></p><ul><li><p>The line in the dataset on which to parse the header</p><ul><li><p>note that commented lines and blank lines do not contribute to this value e.g. if the first 3 lines of your dataset are comments, you&#39;ll still need to set <code>header=1</code> to interpret the first line of parsed data as the header.</p></li></ul></li><li><p>default: <code>header=0</code></p><ul><li><p>no header is checked for by default</p></li></ul></li><li><p>frequently used:</p><ul><li><p><code>header=1</code></p></li></ul></li></ul></li><li><p><code>skiprows::AbstractVector{Int}</code></p><ul><li><p>A <code>Vector</code> or <code>Range</code> (e.g. <code>1:10</code>) or rows to skip</p><ul><li><p>note that this is 1-based in reference to the first row <em>AFTER</em> the header. If <code>header=0</code> or is provided by the user, this will be the first non-empty line in the dataset. Otherwise <code>skiprows=1:1</code> will skip the <code>header+1</code>-nth line in the file.</p></li></ul></li><li><p>default: <code>skiprows=Vector{Int}()</code></p><ul><li><p>no rows are skipped</p></li></ul></li><li><p>frequently used:</p><ul><li><p><code>skiprows=6:typemax(Int)</code></p><ul><li><p>read only the first 5 lines of the dataset</p></li></ul></li></ul></li></ul></li><li><p><code>types::Union{Type, Dict{Int, Type}, Dict{String, Type}, Vector{Type}}</code></p><ul><li><p>declare the types of the columns</p><ul><li><p>scalar, e.g. <code>types=Bool</code></p><ul><li><p>scalars will be broadcast to apply to every column of the dataset</p></li></ul></li><li><p>vector, e.g. <code>types=[Bool, Int, Float64, String, Symbol, Date, DateTime]</code></p><ul><li><p>the vector length must match the number of parsed columns</p></li></ul></li><li><p>dictionary, e.g. <code>types=(&quot;column1&quot; =&gt; Bool)</code> or <code>types=(1 =&gt; Union{Int, Null})</code></p><ul><li><p>users can refer to the columns by name (only if a header is provided or parsed!) or by index</p></li></ul></li></ul></li><li><p>default:</p><ul><li><p><code>types=Dict{Int,DataType}()</code></p><ul><li><p>column-types will be interpreted from the dataset</p></li></ul></li></ul></li><li><p>built-in support for parsing the following:</p><ul><li><p><code>Int</code></p></li><li><p><code>Float64</code></p></li><li><p><code>String</code></p></li><li><p><code>Symbol</code></p></li><li><p><code>Date</code> – only the default date format will work</p></li><li><p><code>DateTime</code> – only the default datetime format will work</p></li><li><p>for other types or unsupported formats, see <code>colparsers</code> and <code>typeparsers</code></p></li></ul></li></ul></li><li><p><code>isnullable::Union{Bool, Dict{Int, Bool}, Dict{String, Bool}, Vector{Bool}}</code></p><ul><li><p>declare whether columns should have element-type <code>Union{T, Null} where T</code></p><ul><li><p>scalar, e.g. <code>isnullable=true</code></p><ul><li><p>scalars will be broadcast to apply to every column of the dataset</p></li></ul></li><li><p>vector, e.g. <code>isnullable=[true, false, true, true]</code></p><ul><li><p>the vector length must match the number of parsed columns</p></li></ul></li><li><p>dictionary, e.g. <code>isnullable=(&quot;column1&quot; =&gt; true)</code> or <code>isnullable=(17 =&gt; true)</code></p><ul><li><p>users can refer to the columns by name (only if a header is provided or parsed!) or by index</p></li></ul></li></ul></li><li><p>default: <code>isnullable=Dict{Int,Bool}()</code></p><ul><li><p>column-types are only nullable if null values are detected in rows <code>1:typedetectrows</code>.</p></li></ul></li></ul></li><li><p><code>coltypes::Union{AbstractVector, Dict{Int, AbstractVector}, Dict{String, AbstractVector}, Vector{AbstractVector}}</code></p><ul><li><p>declare the type of vector that should be used for columns</p></li><li><p>should work for any AbstractVector that allows <code>push!</code>ing values</p><ul><li><p>scalar, e.g. <code>coltypes=CategoricalVector</code></p><ul><li><p>scalars will be broadcast to apply to every column of the dataset</p></li></ul></li><li><p>vector, e.g. <code>coltypes=[CategoricalVector, Vector, CategoricalVector]</code></p><ul><li><p>the vector length must match the number of parsed columns</p></li></ul></li><li><p>dictionary, e.g. <code>coltypes=(&quot;column1&quot; =&gt; CategoricalVector)</code> or <code>coltypes=(17 =&gt; CategoricalVector)</code></p><ul><li><p>users can refer to the columns by name (only if a header is provided or parsed!) or by index</p></li></ul></li></ul></li><li><p>default: <code>coltypes=Vector</code></p><ul><li><p>all columns are returned as standard julia <code>Vector</code>s</p></li></ul></li></ul></li><li><p><code>colparsers::Union{Function, Dict{Int, Function}, Dict{String, Function}, Vector{Function}}</code></p><ul><li><p>provide custom functions for converting parsed strings to values by column</p><ul><li><p>scalar, e.g. <code>colparsers=(x -&gt; parse(Float64, replace(x, &#39;,&#39;, &#39;.&#39;)))</code></p><ul><li><p>scalars will be broadcast to apply to every column of the dataset</p></li></ul></li><li><p>vector, e.g. <code>colparsers=[x -&gt; mydateparser(x), x -&gt; mytimeparser(x)]</code></p><ul><li><p>the vector length must match the number of parsed columns</p></li></ul></li><li><p>dictionary, e.g. <code>colparsers=(&quot;column1&quot; =&gt; x -&gt; mydateparser(x))</code></p><ul><li><p>users can refer to the columns by name (only if a header is provided or parsed!) or by index</p></li></ul></li></ul></li><li><p>default: <code>colparsers=Dict{Int,Function}()</code></p><ul><li><p>column parsers are determined based on user-specified types and those detected from the data</p></li></ul></li></ul></li><li><p><code>typeparsers::Dict{Type, Function}</code></p><ul><li><p>provide custom functions for converting parsed strings to values by column type</p><ul><li><p>note user must specify column types for this to have the intended effect, as the parser uses the default type-parsers for detecting column type.</p></li></ul></li><li><p>default: <code>colparsers=Dict{DataType, Function}()</code></p><ul><li><p>column parsers are determined based on user-specified types and those detected from the data</p></li></ul></li><li><p>frequently used:</p><ul><li><p><code>typeparsers=Dict(Int =&gt; x -&gt; parse(Float64, replace(x, &#39;,&#39;, &#39;.&#39;)))</code> # euro-style floats!</p><ul><li><p>in combination with <code>types</code> to specify which columns to apply the parsers to.</p></li></ul></li></ul></li></ul></li><li><p><code>typedetectrows::Int=1</code></p><ul><li><p>specify how many rows of data to read before interpretting the values that each column should take on</p><ul><li><p>commented, skipped, and empty lines are not counted when determining which rows are used for type detection, e.g. setting <code>typedetectrows=10</code> and <code>skiprows=1:5</code> means type detection will occur on rows <code>6:15</code></p></li></ul></li></ul></li><li><p><code>skipmalformed::Bool=false</code></p><ul><li><p>specify whether the parser should skip a line or fail with an error if a line is parsed but does not contain the expected number of rows</p></li><li><p>default: <code>skipmalformed=false</code></p><ul><li><p>malformed lines result in an error</p></li></ul></li></ul></li><li><p><code>trimwhitespace::Bool=false</code></p><ul><li><p>specify whether should extra whitespace be removed from the beginning and ends of fields.</p></li><li><p>leading and trailing whitespace <em>OUTSIDE</em> of quoted fields is trimmed by default.</p></li><li><p><code>trimwhitespace=true</code> will also trim leading and trailing whitespace <em>WITHIN</em> quotes</p></li></ul></li></ul></div><a class="source-link" target="_blank" href="https://github.com/cjprybol/uCSV.jl/tree/8322eb7b21a588a9d3627c57e41213ae0f8d276b/src/read.jl#L1-L181">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="uCSV.write" href="#uCSV.write"><code>uCSV.write</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">function write(fullpath;
               header=null,
               data=null,
               delim=&#39;,&#39;,
               quotes=null,
               quotetypes=AbstractString)</code></pre><p>write a dataset to disk or IO</p><p><strong>Arguments</strong></p><ul><li><p><code>fullpath::Union{String, IO}</code></p><ul><li><p>the path on disk or IO where you want to write to.</p></li></ul></li><li><p><code>header::Union{Vector{String}, Null}</code></p><ul><li><p>the column names for the data</p><ul><li><p>default: <code>header=null</code></p><ul><li><p>no header is written</p></li></ul></li></ul></li></ul></li><li><p><code>data::Union{Vector{&lt;:Any}, Null}</code></p><ul><li><p>the dataset to write to disk or IO</p><ul><li><p>default: <code>data=null</code></p><ul><li><p>no data is written</p></li></ul></li></ul></li></ul></li><li><p><code>delim::Union{Char, String}</code></p><ul><li><p>the delimiter to seperate fields by</p></li><li><p>default: <code>delim=&#39;,&#39;</code></p><ul><li><p>for CSV files</p></li></ul></li><li><p>frequently used:</p><ul><li><p><code>delim=&#39;\t&#39;</code></p></li><li><p><code>delim=&#39; &#39;</code></p></li><li><p><code>delim=&#39;|&#39;</code></p></li></ul></li></ul></li><li><p><code>quotes::Union{Char, Null}</code></p><ul><li><p>the quoting character to use when writing fields</p><ul><li><p>default: <code>quotes=null</code></p><ul><li><p>fields are not quoted by default, and fields are written using julia&#39;s default string-printing mechanisms</p></li></ul></li></ul></li></ul></li><li><p><code>quotetypes::Type</code></p><ul><li><p>when quoting fields, quote only columns where <code>coltype &lt;: quotetypes</code></p><ul><li><p>default: <code>quotetypes=AbsractString</code></p><ul><li><p>only the header and fields where <code>coltype &lt;: AbsractString</code> will be quoted</p></li><li><p>note that columns of <code>Union{&lt;:coltype, Null}</code> will also be quoted, for cases where columns that you desire to be quoted also have missing values.</p></li></ul></li><li><p>frequently used:</p><ul><li><p><code>quotetypes=Any</code></p><ul><li><p>quote every field in the dataset</p></li></ul></li></ul></li></ul></li></ul></li></ul></div><a class="source-link" target="_blank" href="https://github.com/cjprybol/uCSV.jl/tree/8322eb7b21a588a9d3627c57e41213ae0f8d276b/src/write.jl#L1-L43">source</a><br/><div><pre><code class="language-none">function write(fullpath,
               df;
               delim=&#39;,&#39;,
               quotes=null,
               quotetypes=AbstractString)</code></pre><p>write a DataFrame to disk or IO</p><p><strong>Arguments</strong></p><ul><li><p><code>fullpath::Union{String, IO}</code></p><ul><li><p>the path on disk or IO where you want to write to.</p></li></ul></li><li><p><code>df::DataFrame</code></p><ul><li><p>the DataFrame to write to disk or IO</p></li></ul></li><li><p><code>delim::Union{Char, String}</code></p><ul><li><p>the delimiter to seperate fields by</p></li><li><p>default: <code>delim=&#39;,&#39;</code></p><ul><li><p>for CSV files</p></li></ul></li><li><p>frequently used:</p><ul><li><p><code>delim=&#39;\t&#39;</code></p></li><li><p><code>delim=&#39; &#39;</code></p></li><li><p><code>delim=&#39;|&#39;</code></p></li></ul></li></ul></li><li><p><code>quotes::Union{Char, Null}</code></p><ul><li><p>the quoting character to use when writing fields</p><ul><li><p>default: <code>quotes=null</code></p><ul><li><p>fields are not quoted by default, and fields are written using julia&#39;s default string-printing mechanisms</p></li></ul></li></ul></li></ul></li><li><p><code>quotetypes::Type</code></p><ul><li><p>when quoting fields, quote only columns where <code>coltype &lt;: quotetypes</code></p><ul><li><p>default: <code>quotetypes=AbsractString</code></p><ul><li><p>only the header and fields where <code>coltype &lt;: AbsractString</code> will be quoted</p></li><li><p>note that columns of <code>Union{&lt;:coltype, Null}</code> will also be quoted, for cases where columns that you desire to be quoted also have missing values.</p></li></ul></li><li><p>frequently used:</p><ul><li><p><code>quotetypes=Any</code></p><ul><li><p>quote every field in the dataset</p></li></ul></li></ul></li></ul></li></ul></li></ul></div><a class="source-link" target="_blank" href="https://github.com/cjprybol/uCSV.jl/tree/8322eb7b21a588a9d3627c57e41213ae0f8d276b/src/write.jl#L94-L129">source</a><br/></section><h2><a class="nav-anchor" id="Manual-1" href="#Manual-1">Manual</a></h2><ul><li><a href="man/defaults.html#Getting-Started-1">Getting Started</a></li><li><a href="man/headers.html#Headers-1">Headers</a></li><li><a href="man/dataframes.html#Reading-into-DataFrames-1">Reading into DataFrames</a></li><li><a href="man/delimiters.html#Delimiters-1">Delimiters</a></li><li><a href="man/missingdata.html#Missing-Data-1">Missing Data</a></li><li><a href="man/declaring-column-element-types.html#Declaring-Column-Element-Types-1">Declaring Column Element Types</a></li><li><a href="man/declaring-column-vector-types.html#Declaring-Column-Vector-Types-1">Declaring Column Vector Types</a></li><li><a href="man/international.html#International-Representations-for-Numbers-1">International Representations for Numbers</a></li><li><a href="man/customparsers.html#Custom-Parsers-1">Custom Parsers</a></li><li><a href="man/quotes-escapes.html#Quotes-and-Escapes-1">Quotes and Escapes</a></li><li><a href="man/comments-skiplines.html#Skipping-Comments-and-Rows-1">Skipping Comments and Rows</a></li><li><a href="man/malformed.html#Malformed-Data-1">Malformed Data</a></li><li><a href="man/url.html#Reading-data-from-URLs-1">Reading data from URLs</a></li><li><a href="man/compressed.html#Reading-Compressed-Datasets-1">Reading Compressed Datasets</a></li><li><a href="man/unsupported.html#Common-formatting-issues-1">Common formatting issues</a></li><li><a href="man/benchmarks.html#Benchmarks-1">Benchmarks</a></li></ul><footer><hr/><a class="next" href="man/defaults.html"><span class="direction">Next</span><span class="title">Getting Started</span></a></footer></article></body></html>
